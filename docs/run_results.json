{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.8.3", "generated_at": "2024-07-29T17:03:06.380579Z", "invocation_id": "7981599c-661c-4cd9-8b5f-d171dfcf9b40", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:03.751032Z", "completed_at": "2024-07-29T17:03:03.752580Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:03.764909Z", "completed_at": "2024-07-29T17:03:03.764923Z"}], "thread_id": "Thread-2", "execution_time": 0.027332305908203125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.mixpanel_integration_tests.event", "compiled": null, "compiled_code": null, "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:04.521132Z", "completed_at": "2024-07-29T17:03:04.531619Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:04.531885Z", "completed_at": "2024-07-29T17:03:04.531890Z"}], "thread_id": "Thread-5", "execution_time": 0.02440500259399414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.mixpanel.stg_mixpanel__user_first_event", "compiled": true, "compiled_code": "\n\n-- using source to look at ALL-TIME events\n-- mixpanel__event is cut off by the `date_range_start` variable\nwith  __dbt__cte__stg_mixpanel__event as (\n\n\nwith events as (\n\n    select \n        \"_file\",\n  \"_line\",\n  \"_fivetran_id\",\n  \"event_id\",\n  \"name\",\n  \"time\",\n  \"distinct_id\",\n  \"properties\",\n  \"insert_id\",\n  \"mp_processing_time_ms\",\n  \"_fivetran_synced\",\n  \"screen_width\",\n  \"wifi\",\n  \"app_release\",\n  \"app_version\",\n  \"os\",\n  \"mp_device_model\",\n  \"city\",\n  \"os_version\",\n  \"mp_country_code\",\n  \"lib_version\",\n  \"manufacturer\",\n  \"radio\",\n  \"carrier\",\n  \"screen_height\",\n  \"app_build_number\",\n  \"model\",\n  \"region\",\n  \"app_version_string\",\n  \"mp_lib\",\n  \"initial_referring_domain\",\n  \"device_id\",\n  \"referrer\",\n  \"current_url\",\n  \"browser\",\n  \"browser_version\",\n  \"initial_referrer\",\n  \"search_engine\",\n  \"referring_domain\",\n  \"bluetooth_version\",\n  \"has_nfc\",\n  \"brand\",\n  \"has_telephone\",\n  \"screen_dpi\",\n  \"google_play_services\",\n  \"had_persisted_distinct_id\",\n  \"bluetooth_enabled\",\n  \"ios_ifa\",\n  \"device\",\n  \"mp_keyword\",\n  \"distinct_id_before_identity\",\n  \"ae_session_length\",\n  \"insert_id_\"\n    from \"postgres\".\"zz_mixpanel\".\"event\"\n\n),\n\nfields as (\n\n    select\n        cast( date_trunc('day', time) as date) as date_day,\n        lower(name) as event_type,\n        cast(time as timestamp ) as occurred_at,\n\n        -- pulls default properties and renames (see macros/staging_columns)\n        -- columns missing from your source table will be completely NULL   \n        \n    \n    \n    _fivetran_synced\n    \n as \n    \n    _fivetran_synced\n    \n, \n    \n    \n    _fivetran_id\n    \n as \n    \n    _fivetran_id\n    \n, \n    \n    \n    ae_session_length\n    \n as app_session_length , \n    \n    \n    app_build_number\n    \n as \n    \n    app_build_number\n    \n, \n    \n    \n    app_version_string\n    \n as app_version , \n    \n    \n    bluetooth_enabled\n    \n as has_bluetooth_enabled , \n    \n    \n    bluetooth_version\n    \n as \n    \n    bluetooth_version\n    \n, \n    \n    \n    brand\n    \n as device_brand , \n    \n    \n    browser\n    \n as \n    \n    browser\n    \n, \n    \n    \n    browser_version\n    \n as \n    \n    browser_version\n    \n, \n    \n    \n    carrier\n    \n as wireless_carrier , \n    \n    \n    city\n    \n as \n    \n    city\n    \n, \n    \n    \n    current_url\n    \n as \n    \n    current_url\n    \n, \n    \n    \n    device\n    \n as device_name , \n    \n    \n    device_id\n    \n as \n    \n    device_id\n    \n, \n    \n    \n    distinct_id\n    \n as people_id , \n    \n    \n    distinct_id_before_identity\n    \n as people_id_before_identified , \n    \n    \n    google_play_services\n    \n as google_play_service_status , \n    \n    \n    has_nfc\n    \n as has_near_field_communication , \n    \n    \n    has_telephone\n    \n as \n    \n    has_telephone\n    \n, \n    \n    \n    initial_referrer\n    \n as \n    \n    initial_referrer\n    \n, \n    \n    \n    initial_referring_domain\n    \n as \n    \n    initial_referring_domain\n    \n, \n    \n    \n    insert_id\n    \n as \n    \n    insert_id\n    \n, \n    \n    \n    lib_version\n    \n as mixpanel_library_version , \n    \n    \n    manufacturer\n    \n as device_manufacturer , \n    \n    \n    model\n    \n as device_model , \n    \n    \n    mp_country_code\n    \n as country_code , \n    \n    \n    mp_keyword\n    \n as referrer_keywords , \n    \n    \n    mp_lib\n    \n as mixpanel_library , \n    \n    \n    mp_processing_time_ms\n    \n as \n    \n    mp_processing_time_ms\n    \n, \n    \n    \n    name\n    \n as event_type_original_casing , \n    \n    \n    os\n    \n as \n    \n    os\n    \n, \n    \n    \n    os_version\n    \n as \n    \n    os_version\n    \n, \n    \n    \n    properties\n    \n as event_properties , \n    \n    \n    radio\n    \n as network_type , \n    \n    \n    referrer\n    \n as \n    \n    referrer\n    \n, \n    \n    \n    referring_domain\n    \n as \n    \n    referring_domain\n    \n, \n    \n    \n    region\n    \n as \n    \n    region\n    \n, \n    \n    \n    screen_dpi\n    \n as screen_pixel_density , \n    \n    \n    screen_height\n    \n as \n    \n    screen_height\n    \n, \n    \n    \n    screen_width\n    \n as \n    \n    screen_width\n    \n, \n    \n    \n    search_engine\n    \n as \n    \n    search_engine\n    \n, \n    \n    \n    wifi\n    \n as has_wifi_connected \n\n\n\n        -- custom properties as specified in your dbt_project.yml\n        \n\n\n\n\n        \n    from events\n\n    where true\n\n)\n\nselect * from fields\n), first_events as (\n\n    select \n        people_id,\n        event_type,\n        min(date_day) as first_event_day\n    \n    from __dbt__cte__stg_mixpanel__event\n    group by 1,2\n\n)\n\nselect * \nfrom first_events", "relation_name": "\"postgres\".\"zz_mixpanel_mixpanel\".\"stg_mixpanel__user_first_event\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:04.508478Z", "completed_at": "2024-07-29T17:03:05.169311Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:05.169666Z", "completed_at": "2024-07-29T17:03:05.169675Z"}], "thread_id": "Thread-4", "execution_time": 0.6631927490234375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.mixpanel.mixpanel__event", "compiled": true, "compiled_code": "\n\nwith  __dbt__cte__stg_mixpanel__event as (\n\n\nwith events as (\n\n    select \n        \"_file\",\n  \"_line\",\n  \"_fivetran_id\",\n  \"event_id\",\n  \"name\",\n  \"time\",\n  \"distinct_id\",\n  \"properties\",\n  \"insert_id\",\n  \"mp_processing_time_ms\",\n  \"_fivetran_synced\",\n  \"screen_width\",\n  \"wifi\",\n  \"app_release\",\n  \"app_version\",\n  \"os\",\n  \"mp_device_model\",\n  \"city\",\n  \"os_version\",\n  \"mp_country_code\",\n  \"lib_version\",\n  \"manufacturer\",\n  \"radio\",\n  \"carrier\",\n  \"screen_height\",\n  \"app_build_number\",\n  \"model\",\n  \"region\",\n  \"app_version_string\",\n  \"mp_lib\",\n  \"initial_referring_domain\",\n  \"device_id\",\n  \"referrer\",\n  \"current_url\",\n  \"browser\",\n  \"browser_version\",\n  \"initial_referrer\",\n  \"search_engine\",\n  \"referring_domain\",\n  \"bluetooth_version\",\n  \"has_nfc\",\n  \"brand\",\n  \"has_telephone\",\n  \"screen_dpi\",\n  \"google_play_services\",\n  \"had_persisted_distinct_id\",\n  \"bluetooth_enabled\",\n  \"ios_ifa\",\n  \"device\",\n  \"mp_keyword\",\n  \"distinct_id_before_identity\",\n  \"ae_session_length\",\n  \"insert_id_\"\n    from \"postgres\".\"zz_mixpanel\".\"event\"\n\n),\n\nfields as (\n\n    select\n        cast( date_trunc('day', time) as date) as date_day,\n        lower(name) as event_type,\n        cast(time as timestamp ) as occurred_at,\n\n        -- pulls default properties and renames (see macros/staging_columns)\n        -- columns missing from your source table will be completely NULL   \n        \n    \n    \n    _fivetran_synced\n    \n as \n    \n    _fivetran_synced\n    \n, \n    \n    \n    _fivetran_id\n    \n as \n    \n    _fivetran_id\n    \n, \n    \n    \n    ae_session_length\n    \n as app_session_length , \n    \n    \n    app_build_number\n    \n as \n    \n    app_build_number\n    \n, \n    \n    \n    app_version_string\n    \n as app_version , \n    \n    \n    bluetooth_enabled\n    \n as has_bluetooth_enabled , \n    \n    \n    bluetooth_version\n    \n as \n    \n    bluetooth_version\n    \n, \n    \n    \n    brand\n    \n as device_brand , \n    \n    \n    browser\n    \n as \n    \n    browser\n    \n, \n    \n    \n    browser_version\n    \n as \n    \n    browser_version\n    \n, \n    \n    \n    carrier\n    \n as wireless_carrier , \n    \n    \n    city\n    \n as \n    \n    city\n    \n, \n    \n    \n    current_url\n    \n as \n    \n    current_url\n    \n, \n    \n    \n    device\n    \n as device_name , \n    \n    \n    device_id\n    \n as \n    \n    device_id\n    \n, \n    \n    \n    distinct_id\n    \n as people_id , \n    \n    \n    distinct_id_before_identity\n    \n as people_id_before_identified , \n    \n    \n    google_play_services\n    \n as google_play_service_status , \n    \n    \n    has_nfc\n    \n as has_near_field_communication , \n    \n    \n    has_telephone\n    \n as \n    \n    has_telephone\n    \n, \n    \n    \n    initial_referrer\n    \n as \n    \n    initial_referrer\n    \n, \n    \n    \n    initial_referring_domain\n    \n as \n    \n    initial_referring_domain\n    \n, \n    \n    \n    insert_id\n    \n as \n    \n    insert_id\n    \n, \n    \n    \n    lib_version\n    \n as mixpanel_library_version , \n    \n    \n    manufacturer\n    \n as device_manufacturer , \n    \n    \n    model\n    \n as device_model , \n    \n    \n    mp_country_code\n    \n as country_code , \n    \n    \n    mp_keyword\n    \n as referrer_keywords , \n    \n    \n    mp_lib\n    \n as mixpanel_library , \n    \n    \n    mp_processing_time_ms\n    \n as \n    \n    mp_processing_time_ms\n    \n, \n    \n    \n    name\n    \n as event_type_original_casing , \n    \n    \n    os\n    \n as \n    \n    os\n    \n, \n    \n    \n    os_version\n    \n as \n    \n    os_version\n    \n, \n    \n    \n    properties\n    \n as event_properties , \n    \n    \n    radio\n    \n as network_type , \n    \n    \n    referrer\n    \n as \n    \n    referrer\n    \n, \n    \n    \n    referring_domain\n    \n as \n    \n    referring_domain\n    \n, \n    \n    \n    region\n    \n as \n    \n    region\n    \n, \n    \n    \n    screen_dpi\n    \n as screen_pixel_density , \n    \n    \n    screen_height\n    \n as \n    \n    screen_height\n    \n, \n    \n    \n    screen_width\n    \n as \n    \n    screen_width\n    \n, \n    \n    \n    search_engine\n    \n as \n    \n    search_engine\n    \n, \n    \n    \n    wifi\n    \n as has_wifi_connected \n\n\n\n        -- custom properties as specified in your dbt_project.yml\n        \n\n\n\n\n        \n    from events\n\n    where true\n\n)\n\nselect * from fields\n), stg_event as (\n\n    select *\n    from __dbt__cte__stg_mixpanel__event\n\n    where \n\n    \n    date_day >= \n\n\n\n    \n\n    \n\n    cast('2020-08-01' as date) + ((interval '1 day') * (-7))\n\n\n\n\n\n    \n),\n\ndupes as (\n\n    select \n        md5(cast(coalesce(cast(insert_id as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(people_id as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(event_type as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(date_day as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) as unique_event_id,\n        *,\n        \n        -- aligned with mixpanel' s deduplication method: https://developer.mixpanel.com/reference/http#event-deduplication\n        -- de-duping on calendar day + insert_id but also on people_id + event_type to reduce the rate of false positives \n        -- using calendar day as mixpanel de-duplicates events at the end of each day\n        row_number() over(partition by insert_id, people_id, event_type, date_day order by mp_processing_time_ms asc) as nth_event_record\n        \n        from stg_event\n\n),\n\ndedupe as (\n\n    select *\n    from dupes\n    where nth_event_record = 1\n\n),\n\npivot_properties as (\n\n    select \n        *,\n        \n\n\n\ncast( date_trunc('day', \n    current_timestamp::timestamp\n) as date) as dbt_run_date\n\n\n\n\n        \n\n    from dedupe\n)\n\nselect * from pivot_properties", "relation_name": "\"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__event\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:05.202408Z", "completed_at": "2024-07-29T17:03:05.209380Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:05.209977Z", "completed_at": "2024-07-29T17:03:05.209985Z"}], "thread_id": "Thread-6", "execution_time": 0.035984039306640625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.mixpanel.unique_mixpanel__event_unique_event_id.3b86331807", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    unique_event_id as unique_field,\n    count(*) as n_records\n\nfrom \"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__event\"\nwhere unique_event_id is not null\ngroup by unique_event_id\nhaving count(*) > 1\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:05.192614Z", "completed_at": "2024-07-29T17:03:05.209690Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:05.210468Z", "completed_at": "2024-07-29T17:03:05.210474Z"}], "thread_id": "Thread-1", "execution_time": 0.03678488731384277, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.mixpanel.not_null_mixpanel__event_unique_event_id.1dd02c3bdc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect unique_event_id\nfrom \"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__event\"\nwhere unique_event_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:04.533236Z", "completed_at": "2024-07-29T17:03:05.345463Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:05.345850Z", "completed_at": "2024-07-29T17:03:05.345859Z"}], "thread_id": "Thread-7", "execution_time": 0.8949899673461914, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.mixpanel.stg_mixpanel__user_event_date_spine", "compiled": true, "compiled_code": "\n\nwith user_first_events as (\n\n    select * \n    from \"postgres\".\"zz_mixpanel_mixpanel\".\"stg_mixpanel__user_first_event\"\n),\n\nspine as (\n\n    select *\n\n    from (\n        \n\n\n\n\n\nwith rawdata as (\n\n    \n\n    \n\n    with p as (\n        select 0 as generated_number union all select 1\n    ), unioned as (\n\n    select\n\n    \n    p0.generated_number * power(2, 0)\n     + \n    \n    p1.generated_number * power(2, 1)\n     + \n    \n    p2.generated_number * power(2, 2)\n     + \n    \n    p3.generated_number * power(2, 3)\n     + \n    \n    p4.generated_number * power(2, 4)\n     + \n    \n    p5.generated_number * power(2, 5)\n     + \n    \n    p6.generated_number * power(2, 6)\n     + \n    \n    p7.generated_number * power(2, 7)\n     + \n    \n    p8.generated_number * power(2, 8)\n     + \n    \n    p9.generated_number * power(2, 9)\n     + \n    \n    p10.generated_number * power(2, 10)\n     + \n    \n    p11.generated_number * power(2, 11)\n     + \n    \n    p12.generated_number * power(2, 12)\n    \n    \n    + 1\n    as generated_number\n\n    from\n\n    \n    p as p0\n     cross join \n    \n    p as p1\n     cross join \n    \n    p as p2\n     cross join \n    \n    p as p3\n     cross join \n    \n    p as p4\n     cross join \n    \n    p as p5\n     cross join \n    \n    p as p6\n     cross join \n    \n    p as p7\n     cross join \n    \n    p as p8\n     cross join \n    \n    p as p9\n     cross join \n    \n    p as p10\n     cross join \n    \n    p as p11\n     cross join \n    \n    p as p12\n    \n    \n\n    )\n\n    select *\n    from unioned\n    where generated_number <= 5330\n    order by generated_number\n\n\n\n),\n\nall_periods as (\n\n    select (\n        \n\n    cast('2010-01-01' as date) + ((interval '1 day') * (row_number() over (order by 1) - 1))\n\n\n    ) as date_day\n    from rawdata\n\n),\n\nfiltered as (\n\n    select *\n    from all_periods\n    where date_day <= \n\n    date_trunc('day', \n    current_timestamp::timestamp\n) + ((interval '1 week') * (1))\n\n\n\n)\n\nselect * from filtered\n\n \n    ) as spine\n     \n    -- every user-event_type will have the same last day. Add 7 days to the lookback to account for the week added above.\n    where date_day >= \n\n\n\n    \n\n    \n\n    cast('2024-08-04' as date) + ((interval '1 day') * (-14))\n\n\n\n\n    \n),\n\nuser_event_spine as (\n\n    select\n        cast(spine.date_day as date) as date_day,\n        user_first_events.people_id,\n        user_first_events.event_type,\n\n        -- will use this in mixpanel__daily_events\n        case when spine.date_day = user_first_events.first_event_day then 1 else 0 end as is_first_event_day,\n\n        md5(cast(coalesce(cast(user_first_events.people_id as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(spine.date_day as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(user_first_events.event_type as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) as unique_key\n\n    from spine\n    join user_first_events\n        on spine.date_day >= user_first_events.first_event_day -- each user-event_type will a record for every day since their first day\n    group by 1,2,3,4,5\n    \n)\n\nselect * from user_event_spine", "relation_name": "\"postgres\".\"zz_mixpanel_mixpanel\".\"stg_mixpanel__user_event_date_spine\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:05.446853Z", "completed_at": "2024-07-29T17:03:05.453111Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:05.453856Z", "completed_at": "2024-07-29T17:03:05.453864Z"}], "thread_id": "Thread-5", "execution_time": 0.022668123245239258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.mixpanel.unique_stg_mixpanel__user_event_date_spine_unique_key.0c665092cc", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    unique_key as unique_field,\n    count(*) as n_records\n\nfrom \"postgres\".\"zz_mixpanel_mixpanel\".\"stg_mixpanel__user_event_date_spine\"\nwhere unique_key is not null\ngroup by unique_key\nhaving count(*) > 1\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:05.442548Z", "completed_at": "2024-07-29T17:03:05.453492Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:05.454477Z", "completed_at": "2024-07-29T17:03:05.454482Z"}], "thread_id": "Thread-4", "execution_time": 0.024009227752685547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.mixpanel.not_null_stg_mixpanel__user_event_date_spine_unique_key.878605098b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect unique_key\nfrom \"postgres\".\"zz_mixpanel_mixpanel\".\"stg_mixpanel__user_event_date_spine\"\nwhere unique_key is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:05.174842Z", "completed_at": "2024-07-29T17:03:05.769071Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:05.769465Z", "completed_at": "2024-07-29T17:03:05.769473Z"}], "thread_id": "Thread-3", "execution_time": 0.5984611511230469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.mixpanel.mixpanel__monthly_events", "compiled": true, "compiled_code": "\n\nwith events as (\n\n    select \n        event_type,\n        occurred_at,\n        unique_event_id,\n        people_id,\n        cast( date_trunc('month', occurred_at) as date) as date_month\n\n    from \"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__event\"\n\n    \n    where date_day >= \n\n\n\n    \n\n    \n\n    cast('2020-08-01' as date) + ((interval '1 month') * (-1))\n\n\n\n\n    \n),\n\nmonth_totals as (\n    \n    select \n        date_month,\n        count(distinct people_id) as total_monthly_active_users\n    from events\n    group by 1\n),\n\nsub as (\n-- aggregate number of events to the month\n        select\n            people_id,\n            event_type,\n            date_month,\n            count(unique_event_id) as number_of_events\n\n        from events\n        group by 1,2,3\n), \n\nuser_monthly_events as (\n\n    select \n        *, \n        -- first time a user did this kind of event\n        min(date_month) over(partition by people_id, event_type) as first_month,\n\n        -- last month that the user performed this kind of event during\n        lag(date_month, 1) over(partition by people_id, event_type order by date_month asc) previous_month_with_event\n\n    from sub\n),\n\nmonthly_metrics as (\n\n    select \n        user_monthly_events.date_month,\n        user_monthly_events.event_type,\n        month_totals.total_monthly_active_users,\n\n        count(distinct user_monthly_events.people_id) as number_of_users,\n        count( distinct case when user_monthly_events.first_month = user_monthly_events.date_month then user_monthly_events.people_id end) as number_of_new_users,\n\n        -- defining repeat user as someone who also performed this action the previous month\n        count(distinct case when user_monthly_events.previous_month_with_event is not null and \n            \n        (\n        (date_part('year', (user_monthly_events.date_month)::date) - date_part('year', (user_monthly_events.previous_month_with_event)::date))\n     * 12 + date_part('month', (user_monthly_events.date_month)::date) - date_part('month', (user_monthly_events.previous_month_with_event)::date))\n     = 1\n            then user_monthly_events.people_id end) as number_of_repeat_users,\n\n        -- defining return user as someone who has performed this action farther in the past\n        count(distinct case when user_monthly_events.previous_month_with_event is not null and\n            \n        (\n        (date_part('year', (user_monthly_events.date_month)::date) - date_part('year', (user_monthly_events.previous_month_with_event)::date))\n     * 12 + date_part('month', (user_monthly_events.date_month)::date) - date_part('month', (user_monthly_events.previous_month_with_event)::date))\n     > 1\n            then user_monthly_events.people_id end) as number_of_return_users,\n\n        sum(user_monthly_events.number_of_events) as number_of_events\n\n    from user_monthly_events\n        left join month_totals using(date_month)\n    group by 1,2,3\n),\n\n-- add churn!\nfinal as (\n\n    select\n        *,\n\n        -- subtract the returned users from the previous month's total users to get the # churned\n        -- note: churned users refer to users who did something last month and not this month\n        coalesce(lag(number_of_users, 1) over(partition by event_type order by date_month asc) - number_of_repeat_users, 0) as number_of_churn_users,\n        date_month || '-' || event_type as unique_key, -- for incremental model :)\n        \n\n\n\ncast( date_trunc('day', \n    current_timestamp::timestamp\n) as date) as dbt_run_date\n\n\n\n\n\n    from monthly_metrics\n)\n\nselect * from final", "relation_name": "\"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__monthly_events\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:05.773177Z", "completed_at": "2024-07-29T17:03:05.782319Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:05.782620Z", "completed_at": "2024-07-29T17:03:05.782627Z"}], "thread_id": "Thread-1", "execution_time": 0.01087808609008789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.mixpanel.not_null_mixpanel__monthly_events_unique_key.1e21eae2aa", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect unique_key\nfrom \"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__monthly_events\"\nwhere unique_key is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:05.778158Z", "completed_at": "2024-07-29T17:03:05.783122Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:05.783609Z", "completed_at": "2024-07-29T17:03:05.783614Z"}], "thread_id": "Thread-7", "execution_time": 0.011473894119262695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.mixpanel.unique_mixpanel__monthly_events_unique_key.c79ff7ea8a", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    unique_key as unique_field,\n    count(*) as n_records\n\nfrom \"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__monthly_events\"\nwhere unique_key is not null\ngroup by unique_key\nhaving count(*) > 1\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:05.182847Z", "completed_at": "2024-07-29T17:03:05.901129Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:05.901360Z", "completed_at": "2024-07-29T17:03:05.901368Z"}], "thread_id": "Thread-2", "execution_time": 0.7287707328796387, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.mixpanel.mixpanel__sessions", "compiled": true, "compiled_code": "\n\n-- need to grab all events for relevant users\nwith events as (\n\n    select \n        event_type,\n        occurred_at,\n        unique_event_id,\n        people_id,\n        date_day,\n        device_id,\n        coalesce(device_id, people_id) as user_id\n\n        \n\n    from \"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__event\"\n\n    -- remove any events, etc\n    where true \n\n    \n\n    -- grab ALL events for each user to appropriately use window functions to sessionize\n    and coalesce(device_id, people_id) in (\n\n        select distinct coalesce(device_id, people_id)\n        from \"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__event\"\n\n        where cast(occurred_at as date) >= \n        \n\n\n\n    \n\n    \n\n    cast('2020-08-01' as date) + ((interval '1 day') * (-7))\n\n\n\n\n    )\n\n    \n),\n\nprevious_event as (\n\n    select \n        *,\n        -- limiting session-eligibility to same calendar day\n        lag(occurred_at) over(partition by user_id, date_day order by occurred_at asc) as previous_event_at\n\n    from events \n\n),\n\nnew_sessions as (\n    \n    select \n        *,\n        -- had the previous session timed out? Either via inactivity or a new calendar day occurring\n        case when \n        (\n        (\n        ((occurred_at)::date - (previous_event_at)::date)\n     * 24 + date_part('hour', (occurred_at)::timestamp) - date_part('hour', (previous_event_at)::timestamp))\n     * 60 + date_part('minute', (occurred_at)::timestamp) - date_part('minute', (previous_event_at)::timestamp))\n     > 30 or previous_event_at is null then 1\n        else 0 end as is_new_session\n\n    from previous_event\n),\n\nsession_numbers as (\n\n    select *,\n\n    -- will cumulatively create session numbers\n    sum(is_new_session) over (\n            partition by user_id, date_day\n            order by occurred_at asc\n            rows between unbounded preceding and current row\n            ) as session_number\n\n    from new_sessions\n),\n\nsession_ids as (\n\n    select\n        *,\n        min(occurred_at) over (partition by user_id, date_day, session_number) as session_started_at,\n        min(date_day) over (partition by user_id, date_day, session_number) as session_started_on_day,\n\n        md5(cast(coalesce(cast(user_id as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(session_number as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(date_day as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) as session_id,\n\n        count(unique_event_id) over (partition by user_id, date_day, session_number, event_type order by occurred_at rows between unbounded preceding and unbounded following) as number_of_this_event_type,\n        count(unique_event_id) over (partition by user_id, date_day, session_number order by occurred_at rows between unbounded preceding and unbounded following) as total_number_of_events\n\n    from session_numbers\n),\n\nsub as (\n\n    select\n        session_id,\n        event_type,\n        count(unique_event_id) as number_of_events\n\n    from session_ids\n    group by 1, 2\n),\n\nagg_event_types as (\n\n    select \n        session_id,\n        -- turn into json\n        \n        case when count(event_type) <= 1000 \n            then '{' || \n    string_agg((event_type || ': ' || number_of_events), ', ')\n\n || '}' \n            else 'Too many event types to render' \n        end\n         as event_frequencies\n    \n    from sub\n    group by 1\n), \n\nsession_join as (\n\n    select \n        session_ids.session_id,\n        session_ids.people_id,\n        session_ids.session_started_at,\n        session_ids.session_started_on_day,\n        session_ids.user_id, -- coalescing of device_id and peeople_id\n        session_ids.device_id,\n        session_ids.total_number_of_events,\n        agg_event_types.event_frequencies,\n        \n\n\n\ncast( date_trunc('day', \n    current_timestamp::timestamp\n) as date) as dbt_run_date\n\n\n\n\n\n        \n    \n    from session_ids\n    join agg_event_types -- join regardless of event type \n        on agg_event_types.session_id = session_ids.session_id\n\n    where session_ids.is_new_session = 1 -- only return fields of first event\n\n    \n    and session_started_on_day >= \n\n\n\n    \n\n    \n\n    cast('2020-08-01' as date) + ((interval '1 day') * (-7))\n\n\n\n\n    \n)\n\nselect * from session_join", "relation_name": "\"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__sessions\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:05.904381Z", "completed_at": "2024-07-29T17:03:05.910511Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:05.911074Z", "completed_at": "2024-07-29T17:03:05.911081Z"}], "thread_id": "Thread-5", "execution_time": 0.008127927780151367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.mixpanel.not_null_mixpanel__sessions_session_id.00ef640478", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect session_id\nfrom \"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__sessions\"\nwhere session_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:05.907526Z", "completed_at": "2024-07-29T17:03:05.910835Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:05.911608Z", "completed_at": "2024-07-29T17:03:05.911624Z"}], "thread_id": "Thread-4", "execution_time": 0.008260011672973633, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.mixpanel.unique_mixpanel__sessions_session_id.39741b17e8", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    session_id as unique_field,\n    count(*) as n_records\n\nfrom \"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__sessions\"\nwhere session_id is not null\ngroup by session_id\nhaving count(*) > 1\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:05.432027Z", "completed_at": "2024-07-29T17:03:06.361522Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:06.361844Z", "completed_at": "2024-07-29T17:03:06.361851Z"}], "thread_id": "Thread-8", "execution_time": 0.933074951171875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.mixpanel.mixpanel__daily_events", "compiled": true, "compiled_code": "\n\nwith events as (\n\n    select \n        event_type,\n        occurred_at,\n        people_id,\n        unique_event_id,\n        date_day\n\n    from \"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__event\"\n\n    \n    where date_day >= \n\n\n\n    \n\n    \n\n    cast('2024-08-04' as date) + ((interval '1 day') * (-27))\n\n\n\n\n    \n),\n\n\ndate_spine as (\n    \n    select *\n    from \"postgres\".\"zz_mixpanel_mixpanel\".\"stg_mixpanel__user_event_date_spine\"\n\n    \n    where date_day >= \n\n\n\n    \n\n    \n\n    cast('2024-08-04' as date) + ((interval '1 day') * (-27))\n\n\n\n\n    \n), \n\nagg_user_events as (\n    \n    select\n        date_day,\n        people_id,\n        event_type,\n        count(unique_event_id) as number_of_events\n\n    from events\n    group by 1,2,3\n), \n\n-- join the spine with event metrics\nspine_joined as (\n    \n    select\n        date_spine.date_day,\n        date_spine.people_id,\n        date_spine.event_type,\n        date_spine.is_first_event_day,\n        coalesce(agg_user_events.number_of_events, 0) as number_of_events\n        \n    from date_spine\n\n    left join agg_user_events\n        on agg_user_events.date_day = date_spine.date_day\n        and agg_user_events.people_id = date_spine.people_id\n        and agg_user_events.event_type = date_spine.event_type\n), \n\ntrailing_events as (\n    \n    select\n        *,\n        sum(number_of_events) over (partition by people_id, event_type order by date_day asc rows between 27 preceding and current row) > 0 as has_event_in_last_28_days,\n        sum(number_of_events) over (partition by people_id, event_type order by date_day asc rows between 6 preceding and current row) > 0 as has_event_in_last_7_days,\n\n        -- defining a repeat user as someone who performed an action on a given day after previously having done so in the last 28 days\n        sum(number_of_events) over (partition by people_id, event_type order by date_day asc rows between 27 preceding and 1 preceding) > 0 \n            and number_of_events > 0 as is_repeat_user\n\n    from spine_joined\n), \n\nagg_event_days as (\n    \n    select\n        date_day,\n        event_type,\n        sum(number_of_events) as number_of_events,\n        sum(case when number_of_events > 0 then 1 else 0 end) as number_of_users,\n\n        -- is_first_event_day is not subject to the timeline criteria\n        sum(case when number_of_events > 0 then is_first_event_day else 0 end) as number_of_new_users, \n        sum(case when is_repeat_user = true then 1 else 0 end) as number_of_repeat_users,\n        \n        sum(case when has_event_in_last_28_days = True then 1 else 0 end) as trailing_users_28d,\n        sum(case when has_event_in_last_7_days = True then 1 else 0 end) as trailing_users_7d\n\n    from trailing_events\n    group by 1,2\n),\n\nfinal as (\n\n    select \n\n        date_day,\n        event_type,\n        number_of_events,\n        number_of_users,\n        number_of_new_users,\n        number_of_repeat_users,\n\n        -- \"return user\" is someone who has done an action on a given day after not doing so for the past 28 days\n        number_of_users - number_of_new_users - number_of_repeat_users as number_of_return_users,\n        trailing_users_28d,\n        trailing_users_7d,\n        event_type || '-' || date_day as unique_key,\n        \n\n\n\ncast( date_trunc('day', \n    current_timestamp::timestamp\n) as date) as dbt_run_date\n\n\n\n\n\n    from agg_event_days\n\n    \n    where date_day >= \n\n\n\n    \n\n    \n\n    cast('2024-08-04' as date) + ((interval '1 day') * (-14))\n\n\n\n\n    \n)\n\nselect *\nfrom final", "relation_name": "\"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__daily_events\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:06.371038Z", "completed_at": "2024-07-29T17:03:06.376098Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:06.376832Z", "completed_at": "2024-07-29T17:03:06.376840Z"}], "thread_id": "Thread-1", "execution_time": 0.012381315231323242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.mixpanel.unique_mixpanel__daily_events_unique_key.f15f55c2fc", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    unique_key as unique_field,\n    count(*) as n_records\n\nfrom \"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__daily_events\"\nwhere unique_key is not null\ngroup by unique_key\nhaving count(*) > 1\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-07-29T17:03:06.365709Z", "completed_at": "2024-07-29T17:03:06.376477Z"}, {"name": "execute", "started_at": "2024-07-29T17:03:06.377495Z", "completed_at": "2024-07-29T17:03:06.377500Z"}], "thread_id": "Thread-6", "execution_time": 0.013467073440551758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.mixpanel.not_null_mixpanel__daily_events_unique_key.5fe2993af8", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect unique_key\nfrom \"postgres\".\"zz_mixpanel_mixpanel\".\"mixpanel__daily_events\"\nwhere unique_key is null\n\n\n", "relation_name": null}], "elapsed_time": 5.01705002784729, "args": {"warn_error_options": {"include": [], "exclude": []}, "indirect_selection": "eager", "select": [], "enable_legacy_logger": false, "populate_cache": true, "log_format_file": "debug", "quiet": false, "write_json": true, "empty_catalog": false, "project_dir": "/Users/catherinefritz/Documents/dbt_packages/mixpanel/dbt_mixpanel/integration_tests", "version_check": true, "use_colors_file": true, "profiles_dir": "/Users/catherinefritz/.dbt", "macro_debugging": false, "send_anonymous_usage_stats": true, "log_path": "/Users/catherinefritz/Documents/dbt_packages/mixpanel/dbt_mixpanel/integration_tests/logs", "source_freshness_run_project_hooks": false, "static_parser": true, "defer": false, "log_format": "default", "log_level_file": "debug", "print": true, "show_resource_report": false, "strict_mode": false, "printer_width": 80, "exclude": [], "log_level": "info", "static": false, "partial_parse_file_diff": true, "use_colors": true, "which": "generate", "vars": {}, "log_file_max_bytes": 10485760, "cache_selected_only": false, "require_resource_names_without_spaces": false, "favor_state": false, "partial_parse": true, "introspect": true, "invocation_command": "dbt docs generate", "require_explicit_package_overrides_for_builtin_materializations": true, "compile": true}}